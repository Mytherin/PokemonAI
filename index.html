<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Pokemon AI</title>
    <!-- stylesheets -->
    <link rel="stylesheet" href="third_party/Treant.css" type="text/css"/>
</head>
<body>

<canvas id="pokemoncanvas" width="800" height="650" style="margin-left:auto;margin-right:auto;float:left;">

</canvas>

<div class="chart" id="decision-tree" style="float:left"></div>

<script src="third_party/raphael.js"></script>
<script src="third_party/Treant.js"></script>

<script>

// 0 for ciomputer A, 100 for computer B
var base_team_id = 0


var canvas = document.getElementById("pokemoncanvas");
var c = canvas.getContext("2d");

SCALE = 8/3;

var HEALTHBAR_HEIGHT = 6*SCALE;
var HEALTHBAR_WIDTH = 80*SCALE;
var HEALTHBAR_FONTSIZE = 10*SCALE;

var INTERFACE_FONTSIZE = 12*SCALE

battle_width = 800;
battle_height = 450;
interface_height = 200

var backgroundImage = new Image();
backgroundImage.src = 'images/background.png';

var interfaceBackground = new Image();
interfaceBackground.src = 'images/wallpaper.jpg';

var initialWallpaperBackground = new Image();
initialWallpaperBackground.src = 'images/wallpaper-initial.png';

var selectionWallpaperBackground = new Image();
selectionWallpaperBackground.src = 'images/wallpaper-selection.png';

var selectionPlayerBackground = new Image();
selectionPlayerBackground.src = 'images/wallpaper-selection-player.png';

var pokemons = [{"id":1,"name":"Bulbasaur","speed":45,"special_defense":65,"special_attack":65,"defense":49,"attack":49,"hp":45,"types":["poison","grass"],"img_front":"images/bulbasaur-front.gif","img_back":"images/bulbasaur-back.gif", "attacks": ["tackle", "razor leaf", "sludge bomb", "sleep powder"]}, {"id":4,"name":"Charmander","speed":65,"special_defense":50,"special_attack":60,"defense":43,"attack":52,"hp":39,"types":["fire"],"img_front":"images/charmander-front.gif","img_back":"images/charmander-back.gif", "attacks": ["ember", "flamethrower", "slash", "brick break"]},{"id":7,"name":"Squirtle","speed":43,"special_defense":64,"special_attack":50,"defense":65,"attack":48,"hp":44,"types":["water"],"img_front":"images/squirtle-front.gif","img_back":"images/squirtle-back.gif", "attacks": ["aqua tail", "bite", "ice beam", "tackle"]},{"id":25,"name":"Pikachu","speed":90,"special_defense":50,"special_attack":50,"defense":40,"attack":55,"hp":35,"types":["electric"],"img_front":"images/pikachu-front.gif","img_back":"images/pikachu-back.gif", "attacks": ["thunderbolt", "quick attack", "thunder wave", "thunder shock"]},{"id":39,"name":"Jigglypuff","speed":20,"special_defense":25,"special_attack":45,"defense":20,"attack":45,"hp":115,"types":["fairy","normal"],"img_front":"images/jigglypuff-front.gif","img_back":"images/jigglypuff-back.gif", "attacks": ["pound", "sing", "body slam", "psychic"]},{"id":52,"name":"Meowth","speed":90,"special_defense":40,"special_attack":40,"defense":35,"attack":45,"hp":40,"types":["normal"],"img_front":"images/meowth-front.gif","img_back":"images/meowth-back.gif", "attacks": ["bite", "slash", "shadow claw", "scratch"]},{"id":56,"name":"Mankey","speed":70,"special_defense":45,"special_attack":35,"defense":35,"attack":80,"hp":40,"types":["fighting"],"img_front":"images/mankey-front.gif","img_back":"images/mankey-back.gif", "attacks": ["karate chop", "cross chop", "night slash", "scratch"]},{"id":16,"name":"Pidgey","speed":56,"special_defense":45,"special_attack":45,"defense":50,"attack":55,"hp":50,"types":["flying","normal"],"img_front":"images/pidgey-front.gif","img_back":"images/pidgey-back.gif", "attacks": ["tackle", "air slash", "gust", "steel wing"]},{"id":23,"name":"Ekans","speed":55,"special_defense":54,"special_attack":40,"defense":44,"attack":60,"hp":35,"types":["poison"],"img_front":"images/ekans-front.gif","img_back":"images/ekans-back.gif", "attacks": ["toxic", "sludge bomb", "mud bomb", "bite"]},{"id":74,"name":"Geodude","speed":20,"special_defense":30,"special_attack":30,"defense":100,"attack":80,"hp":40,"types":["ground","rock"],"img_front":"images/geodude-front.gif","img_back":"images/geodude-back.gif", "attacks": ["rock throw", "earthquake", "tackle", "double-edge"]},{"id":96,"name":"Drowzee","speed":42,"special_defense":90,"special_attack":43,"defense":45,"attack":48,"hp":60,"types":["psychic"],"img_front":"images/drowzee-front.gif","img_back":"images/drowzee-back.gif", "attacks": ["psychic", "hypnosis", "pound", "headbutt"]},{"id":92,"name":"Gastly","speed":80,"special_defense":35,"special_attack":100,"defense":40,"attack":35,"hp":30,"types":["poison","ghost"],"img_front":"images/gastly-front.gif","img_back":"images/gastly-back.gif", "attacks": ["hypnosis", "sucker punch", "shadow ball", "lick"]},{"id":12,"name":"Butterfree","speed":70,"special_defense":70,"special_attack":80,"defense":40,"attack":35,"hp":60,"types":["flying","bug"],"img_front":"images/butterfree-front.gif","img_back":"images/butterfree-back.gif", "attacks": ["bug buzz", "poison powder", "psybeam", "air slash"]},{"id":147,"name":"Dratini","speed":50,"special_defense":50,"special_attack":50,"defense":45,"attack":64,"hp":41,"types":["dragon"],"img_front":"images/dratini-front.gif","img_back":"images/dratini-back.gif", "attacks": ["twister", "dragon rush", "thunder wave", "aqua tail"]}]

var attacks = [{"name": "tackle", "power": 40, "type": "normal", "status": "none", "special": false}, {"name": "air slash", "power": 75, "type": "flying", "status": "none", "special": true}, {"name": "gust", "power": 40, "type": "flying", "status": "none", "special": true}, {"name": "steel wing", "power": 70, "type": "steel", "status": "none", "special": false}, {"name": "thunderbolt", "power": 90, "type": "electric", "status": "none", "special": true}, {"name": "quick attack", "power": 40, "type": "normal", "status": "none", "priority": 1, "special": false}, {"name": "thunder wave", "power": 0, "type": "electric", "status": "paralyzed", "special": true}, {"name": "thunder shock", "power": 40, "type": "electric", "status": "none", "special": true}, {"name": "razor leaf", "power": 55, "type": "grass", "status": "none", "special": false}, {"name": "sleep powder", "power": 0, "type": "grass", "status": "sleep", "special": true}, {"name": "sludge bomb", "power": 90, "type": "poison", "status": "none", "special": true}, {"name": "ember", "power": 40, "type": "fire", "status": "none", "special": true}, {"name": "flamethrower", "power": 90, "type": "fire", "status": "none", "special": true}, {"name": "slash", "power": 70, "type": "normal", "status": "none", "special": false}, {"name": "brick break", "power": 75, "type": "fighting", "status": "none", "special": false}, {"name": "aqua tail", "power": 90, "type": "water", "status": "none", "special": false}, {"name": "bite", "power": 60, "type": "dark", "status": "none", "special": false}, {"name": "ice beam", "power": 90, "type": "ice", "status": "none", "special": true}, {"name": "pound", "power": 40, "type": "normal", "status": "none", "special": false}, {"name": "sing", "power": 0, "type": "normal", "status": "sleep", "special": false}, {"name": "body slam", "power": 85, "type": "normal", "status": "none", "special": false}, {"name": "psychic", "power": 90, "type": "psychic", "status": "none", "special": true}, {"name": "scratch", "power": 40, "type": "normal", "status": "none", "special": false}, {"name": "shadow claw", "power": 70, "type": "ghost", "status": "none", "special": false}, {"name": "karate chop", "power": 50, "type": "fighting", "status": "none", "special": false}, {"name": "cross chop", "power": 100, "type": "fighting", "status": "none", "special": false},  {"name": "night slash", "power": 70, "type": "dark", "status": "none", "special": false}, {"name": "toxic", "power": 0, "type": "poison", "status": "toxic", "special": true}, {"name": "mud bomb", "power": 65, "type": "ground", "status": "none", "special": true}, {"name": "rock throw", "power": 50, "type": "rock", "status": "none", "special": false}, {"name": "earthquake", "power": 100, "type": "ground", "status": "none", "special": false},  {"name": "double-edge", "power": 120, "type": "normal", "status": "none", "special": false, "recoil": 0.33}, {"name": "hypnosis", "power": 0, "type": "psychic", "status": "sleep", "special": true}, {"name": "pound", "power": 40, "type": "normal", "status": "none", "special": false}, {"name": "headbutt", "power": 70, "type": "normal", "status": "none", "special": false}, {"name": "sucker punch", "power": 70, "type": "dark", "status": "none", "special": false}, {"name": "shadow ball", "power": 80, "type": "ghost", "status": "none", "special": false}, {"name": "lick", "power": 30, "type": "ghost", "status": "none", "special": false}, {"name": "poison powder", "power": 0, "type": "poison", "status": "poison", "special": true}, {"name": "air slash", "power": 75, "type": "flying", "status": "none", "special": true}, {"name": "psybeam", "power": 65, "type": "psychic", "status": "none", "special": true}, {"name": "bug buzz", "power": 90, "type": "bug", "status": "none", "special": true}, {"name": "twister", "power": 40, "type": "dragon", "status": "none", "special": true}, {"name": "dragon rush", "power": 100, "type": "dragon", "status": "none", "special": false}, {"name": "thunder wave", "power": 0, "type": "electric", "status": "paralysis", "special": true},  {"name": "aqua tail", "power": 90, "type": "water", "status": "none", "special": false}]

function getAttackInfo(attackName) {
	for (var i = 0; i < attacks.length; i++) {
		if (attacks[i].name.toLowerCase() == attackName.toLowerCase()) {
			return attacks[i]
		}
	}
	return {}
}

var type_colors = {}
type_colors["water"] = "#63B8FF"
type_colors["electric"] = "#CDCD00"
type_colors["fire"] = "#B22222"
type_colors["grass"] = "#228B22"
type_colors["ghost"] = "#5D478B"
type_colors["psychic"] = "#CD6090"
type_colors["normal"] = "#6C7B8B"
type_colors["fighting"] = "#8B4513"
type_colors["flying"] = "#a890f0"
type_colors["poison"] = "#a040a0"
type_colors["ghost"] = "#705898"
type_colors["dark"] = "#705848"
type_colors["dragon"] = "#7038f8"
type_colors["bug"] = "#a8b820"
type_colors["psychic"] = "#f85888"
type_colors["ice"] = "#98d8d8"
type_colors["steel"] = "#b8b8d0"
type_colors["fairy"] = "#CD1076"
type_colors["rock"] = "#8B4513"
type_colors["ground"] = "#F4A460"

type_array = ["Normal", "Fighting", "Flying", "Poison", "Ground", "Rock", "Bug", "Ghost", "Steel", "Fire", "Water", "Grass", "Electric", "Psychic", "Ice", "Dragon", "Dark", "Fairy"]
weaknesses = [[1, 1, 1, 1, 1, 0.5, 1, 0, 0.5, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 1, 0.5, 0.5, 1, 2, 0.5, 0, 2, 1, 1, 1, 1, 0.5, 2, 1, 2, 0.5], [1, 2, 1, 1, 1, 0.5, 2, 1, 0.5, 1, 1, 2, 0.5, 1, 1, 1, 1, 1], [1, 1, 1, 0.5, 0.5, 0.5, 1, 0.5, 0, 1, 1, 2, 1, 1, 1, 1, 1, 2], [1, 1, 0, 2, 1, 2, 0.5, 1, 2, 2, 1, 0.5, 2, 1, 1, 1, 1, 1], [1, 0.5, 2, 1, 0.5, 1, 2, 1, 0.5, 2, 1, 1, 1, 1, 2, 1, 1, 1], [1, 0.5, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 0.5, 1, 2, 1, 2, 1, 1, 2, 0.5], [0, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 0.5, 1], [1, 1, 1, 1, 1, 2, 1, 1, 0.5, 0.5, 0.5, 1, 0.5, 1, 2, 1, 1, 2], [1, 1, 1, 1, 1, 0.5, 2, 1, 2, 0.5, 0.5, 2, 1, 1, 2, 0.5, 1, 1], [1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 0.5, 0.5, 1, 1, 1, 0.5, 1, 1], [1, 1, 0.5, 0.5, 2, 2, 0.5, 1, 0.5, 0.5, 2, 0.5, 1, 1, 1, 0.5, 1, 1], [1, 1, 2, 1, 0, 1, 1, 1, 1, 1, 2, 0.5, 0.5, 1, 1, 0.5, 1, 1], [1, 2, 1, 2, 1, 1, 1, 1, 0.5, 1, 1, 1, 1, 0.5, 1, 1, 0, 1], [1, 1, 2, 1, 2, 1, 1, 1, 0.5, 0.5, 0.5, 2, 1, 1, 0.5, 2, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0.5, 1, 1, 1, 1, 1, 1, 2, 1, 0], [1, 0.5, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 0.5, 0.5], [1, 2, 1, 0.5, 1, 1, 1, 1, 0.5, 0.5, 1, 1, 1, 1, 1, 2, 2, 1]]

function getTypeIndex(type) {
	for (var i = 0; i < type_array.length; i++) {
		if (type_array[i].toLowerCase() == type.toLowerCase()) {
			return i
		}
	}
	return 0
}

var pokemon_images = {}

STATUS_NONE = 1;
STATUS_PARALYZED = 2;
STATUS_SLEEP = 3;
STATUS_POISON = 4;
STATUS_BURN = 5;
STATUS_TOXIC = 6;

var p1pokemon = []
var p2pokemon = []
var active_pokemon_p1 = 0
var active_pokemon_p2 = 0

status_array = ["???", "none", "paralyzed", 'sleep', 'poison', 'burn', 'toxic'];

for(var i = 0; i < 3; i++) {
	p1pokemon.push({'index': 7, 'health': 1, 'display_health': 1, 'status': STATUS_NONE, 'frame': 0, 'table': []})
	p2pokemon.push({'index': 12, 'health': 1, 'display_health': 1, 'status': STATUS_NONE, 'frame': 0, 'table': []})
}
p1pokemon[1].index = 4;
p1pokemon[2].index = 0
p2pokemon[1].index = 5
p2pokemon[2].index = 6

callWheneverActualPokemonChanges(p1pokemon[active_pokemon_p1], team_id);

var HEALTH_ANIMATION_SPEED = 0.01;

String.prototype.toProperCase = function () {
    return this.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
};

for (var i = 0; i < pokemons.length; i++) {
	var pkmn = pokemons[i].name.toLowerCase();
	pokemon_images[pkmn] = {};
	var image = new Image();
	image.src = 'images/' + pkmn + '-front.png'
	pokemon_images[pkmn].front = image;
	var image = new Image();
	image.src = 'images/' + pkmn + '-back.png'
	pokemon_images[pkmn].back = image;
	var image = new Image();
	image.src = 'images/' + pkmn + '-front-damaged.png'
	pokemon_images[pkmn].front_damaged = image;
	var image = new Image();
	image.src = 'images/' + pkmn + '-back-damaged.png'
	pokemon_images[pkmn].back_damaged = image;
}
var pokeball_image = new Image();
pokeball_image.src = 'images/pokeball.png'
var pokeball_empty_image = new Image();
pokeball_empty_image.src = 'images/pokeball-empty.png'

function drawBackground(c, backgroundImage, x, y, width, height) {
	c.drawImage(backgroundImage, x, y, width, height);
}

function drawType(type, x, y, width, fontsize) {
	old_style = c.fillStyle;
	old_font = c.font;

	c.font = "bold " + fontsize + "px Calibri";
	c.fillStyle = type_colors[type];
	c.fillRect(x, y, width, 10*SCALE);

	c.strokeStyle = "#000000"
	c.strokeRect(x, y, width, 10*SCALE);

	var size = c.measureText(type.toProperCase());
	c.fillStyle = "#FFFFFF"
	c.fillText(type.toProperCase(), x + (width - size.width) / 2, y + 4*SCALE + (fontsize - 2*SCALE) / 2)
	c.fillStyle = old_style
	c.font = old_font;
}

function drawHealthBar(c, x, y, percentage, name, types, pkmn, isFront) {
	c.font = "bold " + HEALTHBAR_FONTSIZE + "px Calibri";

	var size = c.measureText("HP");
	c.fillStyle = "#222222"
	c.fillText("HP", x - size.width - 5*SCALE, y + HEALTHBAR_FONTSIZE / 4);

	// first draw the background of the health bar
	var grd = c.createLinearGradient(x, y - HEALTHBAR_HEIGHT / 2, x, y + HEALTHBAR_HEIGHT / 2);
	grd.addColorStop(0.0, "#B2B2B2");
	grd.addColorStop(0.5, "#FFFFFF");
	grd.addColorStop(1.0, "#B2B2B2");

	c.fillStyle = grd;
	c.fillRect(x, y - HEALTHBAR_HEIGHT / 2, HEALTHBAR_WIDTH, HEALTHBAR_HEIGHT);

	// now draw the foreground
	var grd = c.createLinearGradient(x, y - HEALTHBAR_HEIGHT / 2, x, y + HEALTHBAR_HEIGHT / 2);
	if (percentage > 0.5) {
		c1 = "#1C472B";
		c2 = "#2BC741";
	} else if (percentage > 0.25) {
		c1 = "#8F3F00";
		c2 = "#FF7F00";
	} else {
		c1 = "#811111";
		c2 = "#B22222";
	}
	grd.addColorStop(0.0, c1);
	grd.addColorStop(0.5, c2);
	grd.addColorStop(1.0, c1);

	c.fillStyle = grd;
	c.fillRect(x, y - HEALTHBAR_HEIGHT / 2, HEALTHBAR_WIDTH * percentage, HEALTHBAR_HEIGHT);
	c.strokeStyle = "#000000";
	c.strokeRect(x, y - HEALTHBAR_HEIGHT / 2, HEALTHBAR_WIDTH, HEALTHBAR_HEIGHT);

	var size = c.measureText(name)
	c.fillStyle = "#000000"
	c.fillText(name, x + (HEALTHBAR_WIDTH - size.width) / 2, y - HEALTHBAR_FONTSIZE / 2);

	c.font = "bold " + (HEALTHBAR_FONTSIZE - 2) + "px Calibri";

	for (var i = 0; i < types.length; i++) {
		var type = types[i];
		c.fillStyle = type_colors[type];
		c.fillRect(x + i * (HEALTHBAR_WIDTH / 2), y + HEALTHBAR_HEIGHT, HEALTHBAR_WIDTH / 2, 10*SCALE);

		c.strokeStyle = "#000000"
		c.strokeRect(x + i * (HEALTHBAR_WIDTH / 2), y + HEALTHBAR_HEIGHT, HEALTHBAR_WIDTH / 2, 10*SCALE);

		var size = c.measureText(type.toProperCase());
		c.fillStyle = "#FFFFFF"
		c.fillText(type.toProperCase(), x + (HEALTHBAR_WIDTH / 2 - size.width) / 2 + i * (HEALTHBAR_WIDTH / 2), y + HEALTHBAR_HEIGHT + 4*SCALE + (HEALTHBAR_FONTSIZE - 2*SCALE) / 2)
	}

	if (pkmn.status != STATUS_NONE) {
		var type = "";
		var name = "";
		if (pkmn.status == STATUS_SLEEP) {
			type = "psychic"
			name = "SLP"
		} else if (pkmn.status == STATUS_PARALYZED) {
			type = "electric"
			name = "PAR"
		} else if (pkmn.status == STATUS_POISON) {
			type = "poison"
			name = "POI"
		}
		c.fillStyle = type_colors[type];
		c.fillRect(x + HEALTHBAR_WIDTH, y, HEALTHBAR_WIDTH / 3, 10*SCALE);

		c.strokeStyle = "#000000"
		c.strokeRect(x + HEALTHBAR_WIDTH, y, HEALTHBAR_WIDTH / 3, 10*SCALE);

		var size = c.measureText(name);
		c.fillStyle = "#FFFFFF"
		c.fillText(name, x + HEALTHBAR_WIDTH + size.width / 4, y + 4*SCALE + (HEALTHBAR_FONTSIZE - 2*SCALE) / 2)
	}

	if (isFront) {
		// p1
		arr = p1pokemon
	} else {
		// p2
		arr = p2pokemon
	}
	for(var i = 0; i < 3; i++) {
		if (arr[i].health > 0) {
			img = pokeball_image;
		} else {
			img = pokeball_empty_image;
		}
		c.drawImage(img, x + i * 28, y + HEALTHBAR_HEIGHT + HEALTHBAR_FONTSIZE + 4, 24, 24);
	}
}

function getPokemonImage(pkmn, isFront, isDamaged) {
	var index = pokemon_images[pokemons[pkmn.index].name.toLowerCase()];
	if (isFront) {
		return isDamaged ? index.front_damaged : index.front;
	} else {
		return isDamaged ? index.back_damaged : index.back;
	}
}

function drawPokemonImage(c, pkmn, image, isFront, x, y, RENDER_SCALE=1, ANIMATION_MULTIPLIER=1, MAXIMUM_SIZE=-1) {
	current_frame = Math.round(pkmn.frame);
	total_frames = Math.round(image.width / image.height);

	var render_size = image.height*SCALE*RENDER_SCALE;
	if (MAXIMUM_SIZE > 0 && render_size > MAXIMUM_SIZE) {
		render_size = MAXIMUM_SIZE;
	} 
	
	c.drawImage(image,
		current_frame * image.height,
		0,
		image.height,
		image.height,
		x,
		y,
		render_size,
		render_size);
	// move to the next frame
	if (pkmn.frame + 1 >= total_frames) {
		pkmn.frame = 0;
	} else {
		pkmn.frame += 0.3 * ANIMATION_MULTIPLIER;
	}
}

function drawPokemon(c, pkmn, isFront) {
	var image;
	var name = pokemons[pkmn.index].name.toProperCase();
	var health = pkmn.display_health;
	var types = pokemons[pkmn.index].types
	if (health > 0) {
		image = getPokemonImage(pkmn, isFront, pkmn.display_health != pkmn.health)
		if (isFront) {
			x = battle_width - 80*SCALE - (image.height*SCALE) / 2;
			y = 90*SCALE - image.height*SCALE;
		} else {
			x = 50*SCALE;
			y = battle_height - 30*SCALE - image.height*SCALE;
		}
		drawPokemonImage(c, pkmn, image, isFront, x, y);
	}
	if (isFront) {
		drawHealthBar(c, 50*SCALE, 30*SCALE, health, name, types, pkmn, isFront);
	} else {
		drawHealthBar(c, battle_width - 40*SCALE - HEALTHBAR_WIDTH, battle_height - 40*SCALE, health, name, types, pkmn, isFront);
	}
}


GLOBAL_INTERFACE_CREATE_NEW_TEAM = 1
GLOBAL_INTERFACE_PLAYER_BATTLE = 2
GLOBAL_INTERFACE_TOURNAMENT_MODE = 3
GLOBAL_INTERFACE_RETRY_BATTLE = 4
GLOBAL_INTERFACE_SELECT_POKEMON_AI = 5
GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER = 6

global_interface = GLOBAL_INTERFACE_CREATE_NEW_TEAM

INTERFACE_SELECT_MOVE = 1
INTERFACE_DISPLAY_TEXT = 2
INTERFACE_SELECT_POKEMON = 3
INTERFACE_BATTLE_OVER = 4

text_stack = []

active_move = 0
selected_pokemon = 0
flicker = 0;
interface_state = INTERFACE_SELECT_MOVE
next_interface = INTERFACE_SELECT_MOVE;


function computeEffectiveness(pkmn, move) {
	var effectiveness = 1;
	attack_type = getTypeIndex(move.type);
	for (var i = 0; i < pkmn.types.length; i++) {
		defending_type = getTypeIndex(pkmn.types[i]);
		effectiveness = effectiveness * weaknesses[attack_type][defending_type]
	}
	return effectiveness;
}

function computeMultiplier(pkmn1, pkmn2, move) {
	var stab_multiplier = 1;
	for (var i = 0; i < pkmn1.types.length; i++) {
		if (pkmn1.types[i].toLowerCase() == move.type.toLowerCase())
			stab_multiplier = 1.3;
	}
	return stab_multiplier * computeEffectiveness(pkmn2, move);
}

String.prototype.format = function () {
	// from https://stackoverflow.com/questions/25227119/javascript-strings-format-is-not-defined
	var args = [].slice.call(arguments);
	return this.replace(/(\{\d+\})/g, function (a){
		return args[+(a.substr(1,a.length-2))||0];
	});
};

function isEmpty(obj) {
	// from https://stackoverflow.com/questions/6072590/how-to-match-an-empty-dictionary-in-javascript
	return Object.keys(obj).length === 0;
}

function mkNode(name) {
	var node = new Object();
	node.text = new Object();
	node.text.name = name;
	node.children = [];

	return node;
}

function mkAttack(name) {
	return mkNode(name);
}

function mkRandAtt() {
	return mkAttack("random");
}

// find stongest attack on 'tbl' and choose between
// exploiting strongest attack and exploring a random attack
function build_tree_prob_attack(tbl) {
	var res = [];
	var max_damage = null;
	var max_attack = null

	for (var i = 0; i < tbl.length; i++) {
		if (!max_damage || tbl[i].damage >= max_damage) {
			max_damage = tbl[i].damage;
			max_attack = tbl[i].attack;
		}
	}

	if (!max_damage) {
		return [mkRandAtt()];
	}

	var prob = getExploitPercent(tbl);
	var rnd = mkNode("{0}% chance".format(prob));
	rnd.children.push(mkAttack(max_attack));
	res.push(rnd);

	var rnd = mkNode("{0}% chance".format(100 - prob));
	rnd.children.push(mkRandAtt());
	res.push(rnd);

	return res;
}

function build_tree_branch_nohealth(tbl) {
	var res = [];

	var opp_status = {};
	for (var i = 0; i < tbl.length; i++) {
		opp_status[tbl[i].state] = 'yes';
	}

	var no_status = status_array[STATUS_NONE];

	for (var ost in opp_status) {
		// partition by oppoent status
		var part = tbl.filter(function(item) { 	
			return ost == item.state;
		});

		part = part.filter(function(item) {
			var info = getAttackInfo(item.attack);
			if (!info.status) {
				console.log("build_tree_branch_nohealth: attack info not found for attack {0}".format(item.attack));
				// whatever, just print it
				return true;
			}

			console.log("attack: {0}, status: {1}".format(item.attack, info.status));

			if (ost === STATUS_NONE) {
				// try to change status
				return !str_eq(no_status, info.status);	
			} else {
				// if we already have a status we only choose attacks that do not change the status
				return str_eq(no_status, info.status);
			}
			
		});

		var nde = mkNode("opp_status = {0}".format(status_array[ost]));
		console.log("opp_status = {0} with {1}".format(status_array[ost], JSON.stringify(part)));
		nde.children = build_tree_prob_attack(part);
		res.push(nde);
	}

	var els = mkNode("else");
	var els_atts = build_tree_prob_attack(tbl);
	els.children = els_atts;

	if (res.length === 0) {
		res = els_atts;
	} else {
		res.push(els);
	}


	return res;
}

function build_tree_branch_health(tbl) {
	var res = [];
	var max_attack = null;
	var max_damage = null;

	for (var i = 0; i < tbl.length; i++) {
		if (!max_damage || tbl[i].damage >= max_damage) {
			max_damage = tbl[i].damage;
			max_attack = tbl[i].attack;	
		}
	}

	if (max_damage) {
		var n = mkNode("opp_health ≤ {0}".format(max_damage.toString()));
		n.children.push(mkAttack(max_attack));

		res.push(n);
	}

	var els = mkNode('else');
	var else_path = build_tree_branch_nohealth(tbl);
	els.children = else_path;

	if (res.length === 0) {
		return else_path;
	}

	res.push(els);

	return res;
}

function build_tree(tbl) {
	var types = {};
	var res = [];

	if (tbl.length === 0) {
		return [mkRandAtt()];
	}

	for (var i = 0; i < tbl.length; i++) {
		types[tbl[i].type] = 'yes';
	}

	var node = mkNode('Root');

	console.log(types);

	for (var tpe in types) {
		var part = tbl.filter(function(item) { 
			return str_eq(tpe, item.type);
		});

		if (part.length < 1) {
			console.log("Less than one entry? Doesn't make sense");
		}

		var nde = mkNode("opp_type = {0}".format(tpe));
		nde.children = build_tree_branch_health(part);
		res.push(nde);
	}

	var els = mkNode("else");
	els.children.push(mkRandAtt());

	if (res.length === 0) {
		els = mkRandAtt();
	}

	res.push(els);

	return res;
}

function updateAI(pkm, responseText) {
	console.log("matrix: %s", responseText);
	var matrix = JSON.parse(responseText);

	// build table from matrix
	var table = [];
	for (var key in matrix) {
		keys = key.split('/');
		var type = keys[0];
		var attack = keys[1];
		var state = keys[2];

		var row = {type: type, attack: attack, state: state, damage : matrix[key].damage};

		console.log(JSON.stringify(row));

		table.push(row);
	}

	pkm.table = table;

	updateDecisionTree(pkm);
}

function updateDecisionTree(pkm) {
	var decision_tree = {
        chart: {
            container: "#decision-tree",
            
            connectors: {
                type: 'step'
            },
            node: {
                HTMLclass: 'nodeExample1'
            }
        },
        nodeStructure: {
        	text: {
        		name : "Root"
        	},

        	children : []
        }
    };

    if (pkm.table.length > 0) {
    	decision_tree.nodeStructure.children = build_tree(pkm.table);
    }

    // and draw it
    new Treant(decision_tree);
}

var screen_flash = 0;


function callWheneverActualPokemonChanges(pkmn1, team) {
	// update matrix and async draw decision tree
	var upd = new Object();
	upd.pokemon = pokemons[pkmn1.index].name;
	console.log(upd.pokemon);
	upd.opp_pokemon = "Pikachu"; // some existing pokemon
	upd.attack = null;
	upd.attack_status = 0;
	upd.opp_status = 0;
	upd.damage = 0;
	upd.team = team;

	var xmlHttp = new XMLHttpRequest();
	xmlHttp.onreadystatechange = function() { 
		if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
			updateAI(pkmn1, xmlHttp.responseText);
		}

	var body = JSON.stringify(upd);
	var url = "update_matrix?json=";
	url = url.concat(encodeURIComponent(body));

	xmlHttp.open("POST", url, true);
	xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	xmlHttp.send(null);
}

function updateMatrixGetNewMatrixAsync(thisPkm, oppPkm, move, damage, team) {
	// update matrix and async draw decision tree
	var upd = new Object();
	upd.pokemon = pokemons[thisPkm.index].name;
	upd.opp_pokemon = pokemons[oppPkm.index].name;
	upd.attack = move.name;
	upd.attack_status = move.status;
	upd.opp_status = oppPkm.status;
	upd.damage = Math.floor(damage);
	upd.team = team;

	var xmlHttp = new XMLHttpRequest();
	xmlHttp.onreadystatechange = function() { 
		if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
			updateAI(thisPkm, xmlHttp.responseText);
		}

	var body = JSON.stringify(upd);
	var url = "update_matrix?json=";
	url = url.concat(encodeURIComponent(body));

	xmlHttp.open("POST", url, true);
	xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	xmlHttp.send(null);
}

function dealDamageToPokemon(params) { 
	var pkmn1 = params[0];
	var pkmn2 = params[1];
	var move = params[2];
	var damage = params[3];
	var update_matrix = params[4];
	var p1 = pokemons[pkmn1.index]
	var p2 = pokemons[pkmn2.index]
	if (move !== undefined && move.status != "none") {
		if (move.status == "paralyzed") {
			pkmn2.status = STATUS_PARALYZED;
			text_stack.splice(1, 0, {"text": p2.name + " is paralyzed!"});
		}
		if (move.status == "sleep") {
			pkmn2.status = STATUS_SLEEP;
			text_stack.splice(1, 0, {"text": p2.name + " fell asleep!"});
		}
		if (move.status == "poison" || move.status == "toxic") {
			pkmn2.status = STATUS_POISON;
			text_stack.splice(1, 0, {"text": p2.name + " is poisoned!"});
		}
	}
	if (damage > 0) {
		screen_flash = 5;
	}
	var current_health = pkmn2.health * p2.hp;
	var new_health = current_health - damage;
	if (new_health <= 0) {
		pkmn2.health = 0;
		is_player = false;
		for(var i = 0; i < 3; i++) {
			if (pkmn2 == p2pokemon[i]) {
				is_player = true;
			}
		}
		text_stack = [text_stack[0], {"text": p2.name.toProperCase() + " has fainted!"}];
		if (is_player) {
			next_interface = INTERFACE_SELECT_POKEMON;
			selected_pokemon = -1;
			for(var i = 0; i < 3; i++) {
				if (p2pokemon[i].health > 0) {
					selected_pokemon = i;
					break;
				}
			}
			if (selected_pokemon < 0) {
				// player has no Pokémon left
				next_interface = INTERFACE_BATTLE_OVER;
				text_stack = [text_stack[0], {"text": "You have no Pokemon left! You have lost the battle!"}]
			}
		} else {
			// AI pokemon has fainted
			var no_pokemon_left = true;
			for(var i = 0; i < 3; i++) {
				if (p1pokemon[i].health > 0) {
					no_pokemon_left = false;
					break;
				}
			}
			if (no_pokemon_left) {
				next_interface = INTERFACE_BATTLE_OVER;
				text_stack = [text_stack[0], {"text": "Your opponent is out of Pokemon! You win!"}]
			} else {
				// FIXME: switch pokemon for AI based on max damage against current pokemon
				new_active_pokemon = -1;
				for(var i = 0; i < 3; i++) {
					if (p1pokemon[i].health > 0) {
						new_active_pokemon = i
						break;
					}
				}
				next_interface = INTERFACE_SELECT_MOVE
				text_stack.push({"text": "The AI send out " + pokemons[p1pokemon[new_active_pokemon].index].name.toProperCase() + ".", "effect": 
					function(params) { active_pokemon_p1 = params[0]; callWheneverActualPokemonChanges(p1pokemon[active_pokemon_p1], team_id); }, "parameters": [new_active_pokemon]})
			}
		}
	} else {
		pkmn2.health = new_health / p2.hp;
	}

	if (move !== undefined && update_matrix) {
		updateMatrixGetNewMatrixAsync(pkmn1, pkmn2, move, damage, team_id);
	}
}

function performMove(pkmn1, pkmn2, move, update_matrix) {
	p1 = pokemons[pkmn1.index]
	p2 = pokemons[pkmn2.index]

	if (pkmn1.status == STATUS_SLEEP) {
		if (Math.random() < 0.6) {
			text_stack.push({"text": p1.name.toProperCase() + " woke up!.", "effect": function(params) { params[0].status = STATUS_NONE }, "parameters": [pkmn1]})
		} else {
			text_stack.push({"text": p1.name.toProperCase() + " is fast asleep!"})
			return;
		}
	}

	if (pkmn1.status == STATUS_PARALYZED && Math.random() < 0.25) {
		text_stack.push({"text": p1.name.toProperCase() + " cannot move due to paralysis."})
		return;
	}


	var multiplier = computeMultiplier(p1, p2, move);
	if (move.special) {
		var attack = p1.special_attack;
		var defense = p2.special_defense;
	} else {
		var attack = p1.attack;
		var defense = p2.defense;
	}
	var damage = 0;
	if (move.power > 0) {
		damage = ((((10 / 5 + 2) * (move.power * (attack / defense))) / 50) + 2) * multiplier;
	}
	text_stack.push({"text": p1.name.toProperCase() + " used " + move.name.toProperCase() + ".", "effect": dealDamageToPokemon, "parameters": [pkmn1, pkmn2, move, damage, update_matrix]});
	if (move.power > 0) {
		var effectiveness = computeEffectiveness(p2, move);
		if (effectiveness < 1) {
			text_stack.push({"text": "It's not very effective."});
		} else if (effectiveness > 1) {
			text_stack.push({"text":  "It's super effective!"});
		}
	}
	if (pkmn1.status == STATUS_POISON) {
		text_stack.push({"text": p1.name.toProperCase() + " took damage from poison.", "effect": dealDamageToPokemon, "parameters": [pkmn2, pkmn1, undefined, p1.hp * 0.1, undefined]});
	}
}

function randBetween(min, max) {
	return Math.floor((Math.random() * (max-min))) + min;
}

// from server.js
function figure_out_type(poke_entry) {
	var types = poke_entry.types;
	types.sort();
	return types.join("");
}

function str_eq(a, b) {
	return a.toUpperCase().localeCompare(b.toUpperCase()) === 0;
}

function getExploitPercent(tbl) {
	var dist_attacks = {};

	tbl.forEach(function(row) {
		dist_attacks[row.attack] = 'exists';
	});

	var num = Object.keys(dist_attacks).length;
	if (num > 4) {
		console.log("getExploitPercent: seen more than 4 attacks against opponent's pokemon's state and type");
		num = 4;
	}

	return 25 * num;
}

function aiEploitOrExplore(tbl, opp_status) {
	// figure out whether to exploit or to explore
	var dist_attacks = {};

	console.log("aiEploitOrExplore opp_status={0}={1}".format(opp_status, status_array[opp_status]));

	var exploit_percent = getExploitPercent(tbl.filter(function(row) {
		return row.state == opp_status;
	}));

	var rand = randBetween(0, 100);
	var exploit = rand <= exploit_percent;
	console.log("aiEploitOrExplore: num_known={0} >= rand={1}".format(exploit_percent, rand));

	return exploit;
}

function aiChooseAttack(thisPkm, oppPkm) {
	// FIXME: Thanks to async updates this has a race condition.
	// But since our AI is kinda randomized, this shouldn't be a
	// big problem.
	var tbl = thisPkm.table;

	var opp_info = pokemons[oppPkm.index];
	var opp_type = figure_out_type(opp_info);
	var opp_status = oppPkm.status;

	var randAttack = () => { return randBetween(0, 4); };

	console.log(opp_type);
	console.log(oppPkm);
	var proper_health = oppPkm.health * pokemons[oppPkm.index].hp;
	console.log(proper_health);

	if (tbl.length === 0) {
		console.log("aiChooseAttack: no matrix");
		return randAttack(); // No matrix
	}

	console.log(tbl);

	// 1. Have we encountered the opponent's type before?
	var tbl = tbl.filter(function(row) {
		console.log("aiChooseAttack: compare types {0} with {1}".format(opp_type, row.type));
		r = str_eq(opp_type, row.type);
		if (r) {
			console.log("aiChooseAttack: equal");
		}
		return r;
	});

	if (tbl.length === 0) {
		console.log("aiChooseAttack: not seen type");
		return randAttack(); // not seen type before
	}

	// 2. Can we kill the opponent using our strongest move?
	var strongest_move = null;
	var max_damage = null;

	tbl.forEach(function(row) {
		if (!max_damage || row.damage >= max_damage) {
			max_damage = row.damage;
			strongest_move = row.attack;
		}
	});

	var attacks = pokemons[thisPkm.index].attacks;

	if (strongest_move && max_damage && max_damage >= proper_health) {
		console.log("aiChooseAttack: Instakill {0}".format(strongest_move));

		// match this strongest move
		for (var i = 0; i < attacks.length; i++) {
			if (str_eq(attacks[i], strongest_move)) {
				return i;
			}
		}
	}

	// no short-cut by killing our dear opponent
	var exploit = aiEploitOrExplore(tbl, opp_status);

	// does he have a status?
	if (opp_status != STATUS_NONE) {
		if (strongest_move && exploit) {
			console.log("aiChooseAttack: opponent has status, strongest move without status {0}".format(strongest_move));
			// match this strongest move
			for (var i = 0; i < attacks.length; i++) {
				if (str_eq(attacks[i], strongest_move)) {
					return i;
				}
			}
		}

		if (!strongest_move) {
			console.log("aiChooseAttack: NO strongest move");
		}		
	} else {
		// try to get some status on opponent
		if (exploit) {
			var status_strongest_move = null;
			var status_max_damage = null;

			var no_status = status_array[STATUS_NONE];

			tbl.forEach(function(row) {
				console.log(row.attack);
				var info = getAttackInfo(row.attack);
				if (!info.status) {
					console.log("aiChooseAttack: attack info not found for attack {0}".format(row.attack));
				}

				if (!str_eq(no_status, info.status) && !status_max_damage || row.damage >= status_max_damage) {
					status_max_damage = row.damage;
					status_strongest_move = row.attack;
				}
			});

			if (status_strongest_move) {
				console.log("aiChooseAttack: strongest move with status {0}".format(status_strongest_move));
				for (var i = 0; i < attacks.length; i++) {
					if (str_eq(attacks[i], status_strongest_move)) {
						return i;
					}
				}
			} else {
				console.log("aiChooseAttack: NO strongest move with status");
				if (strongest_move) {
					console.log("aiChooseAttack: strongest move without status {0}".format(strongest_move));
					for (var i = 0; i < attacks.length; i++) {
						if (str_eq(attacks[i], strongest_move)) {
							return i;
						}
					}
				} else {
					console.log("aiChooseAttack: NO strongest move");
				}
			}
		}	
	}


	console.log("aiChooseAttack: fallback");
	return randAttack();
}

function selectMove() {
	if (interface_state != INTERFACE_SELECT_MOVE) return;
	// FIXME: other pokemon uses AI to select a move
	var p1_attack = getAttackInfo(pokemons[p1pokemon[active_pokemon_p1].index].attacks[
		aiChooseAttack(p1pokemon[active_pokemon_p1], p2pokemon[active_pokemon_p2])
		// randBetween(0,4)
		]);
	var p2_attack = getAttackInfo(pokemons[p2pokemon[active_pokemon_p2].index].attacks[active_move])

	// speed resolution
	p1_goes_first = true;
	if (typeof(p1_attack.priority) === undefined && typeof(p2_attack.priority) !== undefined) {
		// player 2 uses a priority move
		p1_goes_first = false;
	} else {
		// speed resolution
		var p1speed = pokemons[p1pokemon[active_pokemon_p1].index].speed
		var p2speed = pokemons[p2pokemon[active_pokemon_p2].index].speed
		if (p1pokemon[active_pokemon_p1].status == STATUS_PARALYZED) {
			p1speed = p1speed / 4
		}if (p2pokemon[active_pokemon_p2].status == STATUS_PARALYZED) {
			p2speed = p2speed / 4
		}
		if (p2speed > p1speed) {
			p1_goes_first = false;
		} else if (p1speed == p2speed) {
			// speed tie, select randomly
			p1_goes_first = Math.random() < 0.5;
		}
	}

	interface_state = INTERFACE_DISPLAY_TEXT;
	next_interface = INTERFACE_SELECT_MOVE;
	text_stack = [""]
	if (p1_goes_first) {
		performMove(p1pokemon[active_pokemon_p1], p2pokemon[active_pokemon_p2], p1_attack, true);
		performMove(p2pokemon[active_pokemon_p2], p1pokemon[active_pokemon_p1], p2_attack, false);
	} else {
		performMove(p2pokemon[active_pokemon_p2], p1pokemon[active_pokemon_p1], p2_attack, false);
		performMove(p1pokemon[active_pokemon_p1], p2pokemon[active_pokemon_p2], p1_attack, true);
	}
	nextText();
}

function nextText() {
	text_stack.shift();
	if (text_stack.length == 0) {
		interface_state = next_interface;
		if (next_interface == INTERFACE_BATTLE_OVER) {
			interface_state = INTERFACE_SELECT_MOVE;
			for(var i = 0; i < 3; i++) {
				p1pokemon[i].health = 1;
				p1pokemon[i].display_health = 1;
			}
			global_interface = GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER;
		}
		return;
	}
	if (text_stack[0].hasOwnProperty("effect")) {
		text_stack[0].effect(text_stack[0].parameters);
	}
}

function selectNextPokemon() {
	// enter, select pokemon
	active_pokemon_p2 = selected_pokemon;
	interface_state = INTERFACE_DISPLAY_TEXT;
	text_stack = [{'text': 'Go, ' + pokemons[p2pokemon[active_pokemon_p2].index].name.toProperCase() + '!'}];
	next_interface = INTERFACE_SELECT_MOVE;
}

function updateInterface() {
	flicker += 1;
}

function drawInterface() {
	c.fillStyle = "#EEEEEE";
	c.fillRect(0, battle_height, battle_width, interface_height);
	c.strokeStyle = "#000000";
	c.strokeRect(0, battle_height, battle_width, interface_height);

	c.font = "bold " + INTERFACE_FONTSIZE + "px Calibri";
	c.fillStyle = "#000000";
	if (interface_state == INTERFACE_SELECT_MOVE) {
		var TYPE_OFFSET = 275
		var TYPE_WIDTH = 100

		var attacks = pokemons[p2pokemon[active_pokemon_p2].index].attacks
		c.fillText(attacks[0].toProperCase(), 60, battle_height + 20 + INTERFACE_FONTSIZE);
		drawType(getAttackInfo(attacks[0]).type, TYPE_OFFSET, battle_height + 35, TYPE_WIDTH, HEALTHBAR_FONTSIZE, HEALTHBAR_FONTSIZE);
		c.strokeRect(10, battle_height + 20, TYPE_OFFSET + TYPE_WIDTH, 50)

		if (mousePos.x >= 10 && mousePos.x <= 10 + TYPE_OFFSET + TYPE_WIDTH && mousePos.y >= battle_height + 20 && mousePos.y <= battle_height + 70) {
			active_move = 0;
			if (mouseDown) {
				selectMove();			
			}
		}
		c.fillText(attacks[1].toProperCase(), 60, battle_height + 80 + INTERFACE_FONTSIZE);
		drawType(getAttackInfo(attacks[1]).type, TYPE_OFFSET, battle_height + 95, TYPE_WIDTH, HEALTHBAR_FONTSIZE, HEALTHBAR_FONTSIZE);
		c.strokeRect(10, battle_height + 80, TYPE_OFFSET + TYPE_WIDTH, 50)

		if (mousePos.x >= 10 && mousePos.x <= 10 + TYPE_OFFSET + TYPE_WIDTH && mousePos.y >= battle_height + 80 && mousePos.y <= battle_height + 130) {
			active_move = 1;
			if (mouseDown) {
				selectMove();			
			}
		}

		c.fillText(attacks[2].toProperCase(), battle_width - 60 - c.measureText(attacks[2].toProperCase()).width, battle_height + 20 + INTERFACE_FONTSIZE);
		drawType(getAttackInfo(attacks[2]).type, battle_width - TYPE_OFFSET - TYPE_WIDTH, battle_height + 35, TYPE_WIDTH, HEALTHBAR_FONTSIZE, HEALTHBAR_FONTSIZE);
		c.strokeRect(battle_width - TYPE_WIDTH - TYPE_OFFSET - 10, battle_height + 20, TYPE_OFFSET + TYPE_WIDTH, 50)

		if (mousePos.x >= battle_width - TYPE_WIDTH - TYPE_OFFSET - 10 && mousePos.x <= battle_width - 10 && mousePos.y >= battle_height + 20 && mousePos.y <= battle_height + 70) {
			active_move = 2;
			if (mouseDown) {
				selectMove();			
			}
		}
		
		c.fillText(attacks[3].toProperCase(), battle_width - 60 - c.measureText(attacks[3].toProperCase()).width, battle_height + 80 + INTERFACE_FONTSIZE);
		drawType(getAttackInfo(attacks[3]).type, battle_width - TYPE_OFFSET - TYPE_WIDTH, battle_height + 95, TYPE_WIDTH, HEALTHBAR_FONTSIZE, HEALTHBAR_FONTSIZE);
		c.strokeRect(battle_width - TYPE_WIDTH - TYPE_OFFSET - 10, battle_height + 80, TYPE_OFFSET + TYPE_WIDTH, 50)

		if (mousePos.x >= battle_width - TYPE_WIDTH - TYPE_OFFSET - 10 && mousePos.x <= battle_width - 10 && mousePos.y >= battle_height + 80 && mousePos.y <= battle_height + 130) {
			active_move = 3;
			if (mouseDown) {
				selectMove();			
			}
		}

		base_y = battle_height + 25;

		if (active_move == 0) {
			x1 = 20;
			x2 = 40;
			x3 = 20;
			y1 = base_y + INTERFACE_FONTSIZE / 5;
			y2 = y1 + INTERFACE_FONTSIZE / 3;
			y3 = y2 + INTERFACE_FONTSIZE / 3;
		} else if (active_move == 1) {
			base_y = battle_height + 85;
			x1 = 20;
			x2 = 40;
			x3 = 20;
			y1 = base_y + INTERFACE_FONTSIZE / 5;
			y2 = y1 + INTERFACE_FONTSIZE / 3;
			y3 = y2 + INTERFACE_FONTSIZE / 3;
		} else if (active_move == 2) {
			x1 = battle_width - 20;
			x2 = battle_width - 40;
			x3 = battle_width - 20;
			y1 = base_y + INTERFACE_FONTSIZE / 5;
			y2 = y1 + INTERFACE_FONTSIZE / 3;
			y3 = y2 + INTERFACE_FONTSIZE / 3;
		} else if (active_move == 3) {
			base_y = battle_height + 85;
			x1 = battle_width - 20;
			x2 = battle_width - 40;
			x3 = battle_width - 20;
			y1 = base_y + INTERFACE_FONTSIZE / 5;
			y2 = y1 + INTERFACE_FONTSIZE / 3;
			y3 = y2 + INTERFACE_FONTSIZE / 3;
		}
		c.beginPath();
	    c.moveTo(x1, y1);
	    c.lineTo(x2, y2);
	    c.lineTo(x3, y3);
	    c.fill();
	} else if (interface_state == INTERFACE_DISPLAY_TEXT) {
		c.fillText(text_stack[0].text, 60, battle_height + 20 + INTERFACE_FONTSIZE);

	    if (p1pokemon[active_pokemon_p1].display_health != p1pokemon[active_pokemon_p1].health || p2pokemon[active_pokemon_p2].display_health != p2pokemon[active_pokemon_p2].health) {
	    	return;
	    }

	    if (mouseDown) {
	    	nextText();
	    }

		if ((flicker % 60) < 30) {
			x1 = battle_width - 60;
			x2 = battle_width - 20;
			x3 = battle_width - 40;
			y1 = battle_height + interface_height - 40;
			y2 = y1;
			y3 = y2 + 20;

			c.beginPath();
		    c.moveTo(x1, y1);
		    c.lineTo(x2, y2);
		    c.lineTo(x3, y3);
		    c.fill();
		}
	} else if (interface_state == INTERFACE_SELECT_POKEMON) {
		for(var i = 0; i < 3; i++) {
			var pkmn = p2pokemon[i];
			if (pkmn.health > 0) {
				var image = getPokemonImage(pkmn, true, false);
				var x = battle_width / 4 + (i * battle_width / 4) - image.height / 2;
				var y = battle_height + interface_height / 4 - image.height / 2

				if (mousePos.x >= x && mousePos.x <= x + 128 && mousePos.y >= y && mousePos.y <= y + 128) {
					selected_pokemon = i;
					if (mouseDown) {
						selectNextPokemon()
					}
				}

				drawPokemonImage(c, pkmn, image, true, x, y, 0.75, selected_pokemon == i ? 1 : 0)
				if (selected_pokemon == i) {
					c.fillText(pokemons[pkmn.index].name, x, battle_height + INTERFACE_FONTSIZE)
				}
			}

		}
	}
}

function update_health(pkmn) {
	if (Math.abs(pkmn.display_health - pkmn.health) <= HEALTH_ANIMATION_SPEED) {
		pkmn.display_health = pkmn.health;
	} else if (pkmn.display_health < pkmn.health) {
		pkmn.display_health += HEALTH_ANIMATION_SPEED;
	} else if (pkmn.display_health > pkmn.health) {
		pkmn.display_health -= HEALTH_ANIMATION_SPEED;
	}
}

function update() {
	updateInterface();
	update_health(p1pokemon[active_pokemon_p1]);
	update_health(p2pokemon[active_pokemon_p2]);
}

var caret_position = 0;
var team_name = ""
var team_id = -1;
var team_name2 = "Player"

function insertLetter(letter) {
	team_name = team_name.slice(0, caret_position) + letter + team_name.substr(caret_position);
	caret_position++;
	team_name = team_name.toProperCase();
}

function deleteLeft() {
	if (caret_position > 0) {
		team_name = team_name.slice(0, caret_position - 1) + team_name.substr(caret_position);
		team_name = team_name.toProperCase();
		caret_position--;
	}
}

var selected_pokemon_list = []
var pokemon_entries = []

for(var i = 0; i < pokemons.length; i++) {
	pokemon_entries.push({'index': i, 'frame': 0});
}

var mousePos = { x: 0, y: 0 }
var mouseDown = false;

function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	};
}

function goNext() {
	if (global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_AI) {
		p1pokemon = []
		for(var i = 0; i < selected_pokemon_list.length; i++) {
			p1pokemon.push({'index': selected_pokemon_list[i], 'health': 1, 'display_health': 1, 'status': STATUS_NONE, 'frame': 0, 'table': []})
		}
		selected_pokemon_list = []
		global_interface = GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER;
    } else if (global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER) {
		p2pokemon = []
		for(var i = 0; i < selected_pokemon_list.length; i++) {
			p2pokemon.push({'index': selected_pokemon_list[i], 'health': 1, 'display_health': 1, 'status': STATUS_NONE, 'frame': 0, 'table': []})
		}
		selected_pokemon_list = []
		setTeam(team_name, p2pokemon);
		global_interface = GLOBAL_INTERFACE_PLAYER_BATTLE;		
		callWheneverActualPokemonChanges(p1pokemon[active_pokemon_p1], team_id);			
    }
}

function drawTeamNames() {
	c.font = "bold 32px Calibri";
	c.fillStyle = '#000000'
	c.fillText(team_name, battle_width - c.measureText(team_name).width - 20, 32);
	c.fillText(team_name2, 20, battle_height - 32);
}

function render() {
	c.fillStyle = '#FFFFFF'
	c.fillRect(0, 0, canvas.width, canvas.height);
	if (global_interface == GLOBAL_INTERFACE_CREATE_NEW_TEAM) {
		drawBackground(c, initialWallpaperBackground, 0, 0, battle_width, battle_height + 50);
		c.font = "bold 32px Calibri";
		c.fillStyle = '#000000'
		c.fillText(team_name, 32, 265 + 26);
		if ((flicker % 60) < 30) {
			c.fillStyle = '#000000'
			var x = 32 + c.measureText(team_name.substr(0, caret_position)).width
			var y = 265;
			c.fillRect(x, y, 2, 32);
		}
	} else if (global_interface == GLOBAL_INTERFACE_PLAYER_BATTLE ||
		global_interface == GLOBAL_INTERFACE_TOURNAMENT_MODE) {
		drawBackground(c, backgroundImage, 0, 0, battle_width, battle_height);
		drawPokemon(c, p2pokemon[active_pokemon_p2], false)
		drawPokemon(c, p1pokemon[active_pokemon_p1], true)
		if (screen_flash > 0) {
			c.fillStyle = '#B22222';
			c.globalAlpha = 0.2;
			c.fillRect(0, 0, battle_width, battle_height);
			c.globalAlpha = 1;
			screen_flash--;
		}
		drawTeamNames();
		if (global_interface == GLOBAL_INTERFACE_PLAYER_BATTLE) {
			drawInterface();
			// drawDecisionTree();
		}
	} else if (global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_AI || global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER) {
		drawBackground(c, global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_AI ? selectionWallpaperBackground : selectionPlayerBackground, 0, 0, battle_width, battle_height + 50);

		if (global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER) {
			var x = 60;
			var y = 50;
			var pokemon_size = 65;
			for(var i = 0; i < p1pokemon.length; i++) {
				var pkmn = p1pokemon[i];
				image = getPokemonImage(pkmn, true, false)
				drawPokemonImage(c, pkmn, image, true, x + i * (10 + pokemon_size), y, 1, 1, pokemon_size);
			}

		}

		var x = 10;
		var y = 128;
		var fontsize = 18
		var pokemon_size = 112

		c.font = "bold " + fontsize + "px Calibri";
		for(var i = 0; i < pokemon_entries.length; i++) {
			var pkmn = pokemon_entries[i];
			image = getPokemonImage(pkmn, true, false)
			if (x + pokemon_size > battle_width) {
				x = 10;
				y += pokemon_size + 32;
			}
			var selected = false;
			for(var j = 0; j < selected_pokemon_list.length; j++) {
				if (selected_pokemon_list[j] == i) {
					selected = true;
					break;
				}
			}
			var hover = false;
			if (mousePos.x >= x && mousePos.x <= x + pokemon_size &&
				mousePos.y >= y && mousePos.y <= y + pokemon_size + fontsize) {
				if (mouseDown) {
					if (!selected) {
						selected_pokemon_list.push(i);
						if (selected_pokemon_list.length > 3) {
							selected_pokemon_list.shift();
						}
						selected = true;
					} else {
						var index = selected_pokemon_list.indexOf(i);
						selected_pokemon_list.splice(index, 1);
						selected = false;
						hover = true;
					}
				} else {
					hover = true;
				}
			}

			if (selected) {
				drawPokemonImage(c, pkmn, image, true, x, y, 1, 0, pokemon_size);
			}
			if (selected || hover) {
				c.globalAlpha = selected ? 0.7 : 0.5
				c.fillStyle = selected ? '#422222' : '#feca30'
				c.fillRect(x, y, pokemon_size, pokemon_size)
				c.strokeStyle = '#3e5ba3'
				c.strokeRect(x, y, pokemon_size, pokemon_size)
				c.globalAlpha = 1
			}

			if (!selected) {
				drawPokemonImage(c, pkmn, image, true, x, y, 1, 1, pokemon_size);
			}
			c.fillStyle = hover ? '#feca30' : '#3e5ba3';
			c.fillRect(x + 5, y + pokemon_size - fontsize, pokemon_size - 10, 25)
			c.fillStyle = hover ? '#3e5ba3' : '#feca30';
			var name = pokemons[pkmn.index].name.toProperCase()
			c.fillText(name, x + (pokemon_size - c.measureText(name).width) / 2, y + pokemon_size);
			x += pokemon_size
		}
		for(var i = 0; i < selected_pokemon_list.length; i++) {
			var pkmn = pokemon_entries[selected_pokemon_list[i]];
			var x = 260 + 100 * i;
			var y = 405;
			image = getPokemonImage(pkmn, true, false)
			drawPokemonImage(c, pkmn, image, true, x, y, 1, 1, 88);
		}

		if (selected_pokemon_list.length == 3) {
			if (mouseDown && mousePos.x >= battle_width - 170 && mousePos.x <= battle_width - 42 && mousePos.y >= battle_height - 32 && mousePos.y <= battle_height + 32) {
				// go next
				goNext();
			}
			c.fillStyle = '#feca30'
			c.fillRect(battle_width - 170, battle_height - 32, 128, 64);
			c.strokeStyle = '#3e5ba3'
			c.strokeRect(battle_width - 170, battle_height - 32, 128, 64);

			c.font = "bold 48px Calibri";
			c.fillStyle = '#3e5ba3'
			c.fillText("GO!", battle_width - 150, battle_height + 16);
		}
	}
}

function loop(timestamp) {
	var t = timestamp - lastRender

	update();
	render();

	mouseDown = false;

	lastRender = timestamp
	window.requestAnimationFrame(loop)
}

function setTeam(nam, pkmns) {
	// update matrix and async draw decision tree
	var upd = new Object();

	team_id = base_team_id;
	upd.team = base_team_id;
	upd.descr = name;

	upd.pokemons = [];
	pkmns.forEach(function(p) {
		upd.pokemons.push(pokemons[p.index].name);
		console.log(pokemons[p.index].name);
	});

	console.log(JSON.stringify(upd.pokemons));

	var xmlHttp = new XMLHttpRequest();
	var body = JSON.stringify(upd);
	var url = "set_team?json=";
	url = url.concat(encodeURIComponent(body));

	xmlHttp.onreadystatechange = function() {
		if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
			JSON.parse(xmlHttp.responseText);
		} else {
			console.log("setTeam: not ready");
		}
	};

	xmlHttp.open("POST", url, true);
	xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	xmlHttp.send(null);

	// FIXME: save current team id 

	base_team_id = base_team_id + 1;

	return true;
}

function getAllTeams() {
	var xmlHttp = new XMLHttpRequest();
	var url = "get_teams";

	xmlHttp.onreadystatechange = function() {
		if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
			// FIXME: do tournament shit here
		} else {
			console.log("getAllTeams: not ready");
		}
	};

	xmlHttp.open("POST", url, true);
	xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	xmlHttp.send(null);

	// FIXME: save current team id 
}

canvas.addEventListener('mousemove', function(evt) {
	mousePos = getMousePos(canvas, evt);
}, false);

canvas.addEventListener('click', function(evt) {
	mousePos = getMousePos(canvas, evt);
	mouseDown = true;
}, false);

document.onkeydown = function(evt) {
    evt = evt || window.event;

    if (evt.keyCode == 27) {
    	team_name = "";
    	global_interface = GLOBAL_INTERFACE_CREATE_NEW_TEAM;
    }

    if (global_interface == GLOBAL_INTERFACE_TOURNAMENT_MODE) {
    	return;
    }

    if (global_interface == GLOBAL_INTERFACE_CREATE_NEW_TEAM) {
    	if (evt.keyCode == 37) {
    		// left arrow
    		caret_position--;
    		if (caret_position < 0)
    			caret_position = 0;
    	}
    	if (evt.keyCode == 39) {
    		// right arrow
    		caret_position++;
    		if (caret_position > team_name.length) {
    			caret_position = team_name.length
    		}
    	}
    	if (evt.keyCode == 8) {
    		deleteLeft()
    	}
    	if (evt.keyCode == 32) {
    		var letter = ' '
    		insertLetter(letter);
    	}
    	if (evt.keyCode >= 65 && evt.keyCode <= 90) {
    		var letters = "abcdefghijklmnopqrstuvwxyz"
    		var letter = letters[evt.keyCode - 65];
    		insertLetter(letter);
    	}
    	if (evt.keyCode == 13) {
			global_interface = GLOBAL_INTERFACE_SELECT_POKEMON_AI	
    	}
    	return;
    } else if (global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_AI) {
    	if (evt.keyCode == 13 && selected_pokemon_list.length == 3) {
    		goNext();
    	}
    	return;
    } else if (global_interface == GLOBAL_INTERFACE_SELECT_POKEMON_PLAYER) {
    	if (evt.keyCode == 13 && selected_pokemon_list.length == 3) {
    		goNext();
    	}
    	return;
    }

    if (p1pokemon[active_pokemon_p1].display_health != p1pokemon[active_pokemon_p1].health || p2pokemon[active_pokemon_p2].display_health != p2pokemon[active_pokemon_p2].health) {
    	return;
    }

    if (interface_state == INTERFACE_SELECT_MOVE) {
		if (evt.keyCode == 40 || evt.keyCode == 38) {
			// down arrow or up arrow
			if (active_move == 0) {
				active_move = 1;
			} else if (active_move == 1) {
				active_move = 0;
			} else if (active_move == 2) {
				active_move = 3;
			} else if (active_move == 3) {
				active_move = 2;
			}
		} else if (evt.keyCode == 37 || evt.keyCode == 39) {
			// left arrow or right arrow
			if (active_move == 0) {
				active_move = 2;
			} else if (active_move == 1) {
				active_move = 3;
			} else if (active_move == 2) {
				active_move = 0;
			} else if (active_move == 3) {
				active_move = 1;
			}
		} else if (evt.keyCode == 13) {
			// enter, select move
			selectMove();
		}
    } else if (interface_state == INTERFACE_DISPLAY_TEXT) {
		if (evt.keyCode == 13) {
			nextText();
		}
    } else if (interface_state == INTERFACE_SELECT_POKEMON) {
    	if (evt.keyCode == 37 || evt.keyCode == 39) {
    		// left or right arrow
    		for(var i = 0; i < 3; i++) {
    			if (p2pokemon[i].health > 0 && i != selected_pokemon) {
    				selected_pokemon = i;
    				break;
    			}
    		}
    	} else if (evt.keyCode == 13) {
    		selectNextPokemon()
		}
    }
};

var lastRender = 0
window.requestAnimationFrame(loop);


getAllTeams();
</script>

</body>
</html>